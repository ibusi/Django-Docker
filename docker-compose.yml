#Compose とは、複数のコンテナを定義し実行する Docker アプリケーションのためのツール

version: '3.3'

#外部から認識できる機能単位を「サービス」と呼ぶ。
#サービスにはコンテナがアタッチされるため、サービスの実態はコンテナ。
services:

  #サービスの構成の一つ
  app:

    #構築時に適用するオプションを指定する。（今回でいえばbuildがオプションになっている）
    build:

      #Dockerfile があるディレクトリのパスやGitリポジトリのURLを指定する
      #値に相対パスを指定したら、Compose ファイルのある場所を基準とした相対パスとして解釈する。
      #また、指定したディレクトリが構築コンテクストとなり、Docker デーモンに送信する。
      context: .

    #公開用のポート。ホスト側とコンテナ側の両方のポートを指定（ ホスト側:コンテナ側 ）できるだけでなく、
    #コンテナ側のポートのみも指定できる（ホスト側はランダムなポートが選ばれる）。
    #ホスト側:コンテナ側 の書式でポートを割り当てる時、コンテナのポートが 60 以下であればエラーが発生する。
    #これは YAML が xx:yy 形式の指定を、60 進数（60が基準）の数値とみなすから。
    #そのため、ポートの割り当てには常に文字列として指定することを推奨（”で囲んで文字扱いにする）
    ports:
      - "8000:8000"  

    #コンテナに指定したローカルのデータをマウント（今回は./appから/appへ）する。
    #リアルタイムでdocker imageに変更が反映される。普通なら、 docker buildで何度もコンテナ作り直す必要があるので便利。
    #データベース的には普段、コンテナを落とすと、コンテナの中のデータは一から作り直しになるが。
    #手元のデータをマウントしているなら、コンテナを立ち上げる度にデータが消えない。
    #ただ、手元のOSの該当ディレクトリを消したら、当然なくなる
    #ローカルの環境では良いが本番では使わない
    volumes:
      - ./app:/app

    #commandはサービス起動後に入力されるコマンドを設定

    #djangoの開発環境で「runserver」コマンドを打つと、2つのサーバーが立ち上がっている。
    #djangoでは、ウェブサーバーとアプリケーションサーバーを用意する必要がある。
    #アクセスの流れは、ブラウザ→ウェブサーバー→アプリケーションサーバー→django
    #指定した0.0.0.0:8000、これはアプリケーションサーバーがアクセスを受けるIPを指定している。
    #0.0.0.0はすべてのネットワーク・インターフェースを表す。(全てのIPアドレス)
    #8000はポートの番号。
    #つまりアプリケーションサーバーが、8000番ポートのどのIPアドレスからもアクセスを受ける。
    #しかし、ウェブサーバーはそれぞれ一つのIPアドレスを有していることが一般的。
    #なので、runserverで0.0.0.0:8000と指定したとしても、ブラウザからはウェブサーバーのIPを指定してあげなければいけない。

    #python manage.py runserverはDjangoの開発サーバを起動する。Djangoの開発サーバはPythonだけで書かれた軽量なWebサーバ。
    #このサーバは、開発を迅速に行い、運用に適した状態になるまでApacheのような運用サーバの設定をいじらなくても良いようにするためのもの。
    #このサーバは開発中の利用だけを考えて作られており。絶対に運用環境では使ってはいけない。
    #ブラウザのhttp://127.0.0.1:8000/ でアクセスできる。
    #127.0.0.1はループバックアドレス（自分自身を表す仮想的なアドレス）

    #sh -c はsh(シェル)のオプション‐c（コマンドを指定された文字列から読み取る）と思われる
    command: sh -c "python manage.py runserver 0.0.0.0:8000"

    #立ち上げたコンテナに環境変数を設定できる。
    #今回でいうとDEBUG（DEBUG=1）という環境変数ができた。
    environment:
      - DEBUG=1